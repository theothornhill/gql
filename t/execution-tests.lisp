(in-package #:gql-tests)

(deftest execution
  (testing "collect-fields returns the correct fields"
    (with-schema (build-schema "{ a { subfield1 } ...ExampleFragment }
                                   fragment ExampleFragment on Query { a { subfield2 } b }")
      (let ((gql::*all-types* (make-hash-table :test #'equal)))
        ;; HACK: omg, eww!
        (setf (gethash "Query" gql::*all-types*)
              (make-instance 'gql::object-type-definition
                             :name (make-instance 'gql::named-type :name "Query")))
        (let* ((operation (car (gql::definitions gql::*schema*)))
               (operation-type (gql::operation-type operation))
               (selection-set (gql::selection-set operation))
               (result (gql::collect-fields operation-type (gql::selections selection-set) nil nil)))
          (ok (= (hash-table-count result) 2))
          (ok (= (length (gethash "a" result)) 2))
          (ok (= (length (gethash "b" result)) 1)))  )))
  (testing "get-operation should return the correct operation"
    (let ((gql::*schema* (build-schema "{ a { subfield1 } } ")))
      (ok (gql::get-operation gql::*schema* "Query")))
    (let ((gql::*schema* (build-schema "query { a { subfield1 } } ")))
      (ok (gql::get-operation gql::*schema*)))
    (let ((gql::*schema* (build-schema "mutation { a { subfield1 } } ")))
      (ok (signals (gql::get-operation gql::*schema* "Query") 'gql::gql-simple-error)))
    (let ((gql::*schema* (build-schema "mutation { a { subfield1 } }
                                   query { a { subfield1 } } ")))
      (ok (signals (gql::get-operation gql::*schema*) 'gql::gql-simple-error)))
    (let ((gql::*schema* (build-schema "mutation { a { subfield1 } } ")))
      (ok (gql::get-operation gql::*schema*)))
    (let ((gql::*schema* (build-schema "mutation { a { subfield1 } } ")))
      (ok (gql::get-operation gql::*schema* "Mutation"))))
  (testing "merge-selection-sets should merge multiple fields"
    (with-schema (build-schema (asdf:system-relative-pathname 'gql-tests #p"t/test-files/validation-schema.graphql"))
      (let ((*resolvers* (make-hash-table :test #'equal))
            (query-resolver (make-hash-table :test #'equal))
            (dog-resolver (make-hash-table :test #'equal))
            (human-resolver (make-hash-table :test #'equal)))
        (setf (gethash "Query" *resolvers*) query-resolver)
        (setf (gethash "Human" *resolvers*) human-resolver)
        (setf (gethash "name" human-resolver) (lambda () "Bingo-bongo-pappa"))
        (setf (gethash "Dog" *resolvers*) dog-resolver)
        (setf (gethash "dog" query-resolver) (lambda () t))
        (setf (gethash "name" dog-resolver) (lambda () "Bingo-bongo"))
        (setf (gethash "owner" dog-resolver) (lambda () t))
        (let* ((res (gql::execute-request (build-schema "query { dog { name } dog { owner { name } } }") nil (make-hash-table) nil))
               (data (gethash "data" res))
               (dog-res (gethash "dog" data)))
          (ok (typep res 'hash-table))
          (ok (= (hash-table-count res) 2))
          (ok (= (hash-table-count dog-res) 2))
          (ok (gethash "name" dog-res))
          (ok (gethash "owner" dog-res))))))
  (testing "A query should handle alias"
    (with-schema (build-schema (asdf:system-relative-pathname 'gql-tests #p"t/test-files/validation-schema.graphql"))
      (let* ((*resolvers* (make-hash-table :test #'equal))
             (query-resolver (make-hash-table :test #'equal))
             (dog-resolver (make-hash-table :test #'equal))
             (human-resolver (make-hash-table :test #'equal)))
        (setf (gethash "Query" *resolvers*) query-resolver)
        (setf (gethash "Human" *resolvers*) human-resolver)
        (setf (gethash "name" human-resolver) (lambda () "Bingo-bongo-pappa"))
        (setf (gethash "Dog" *resolvers*) dog-resolver)
        (setf (gethash "dog" query-resolver) (lambda () t))
        (setf (gethash "name" dog-resolver) (lambda () "Bingo-bongo"))
        (setf (gethash "owner" dog-resolver) (lambda () t))
        (let* ((res (gql::execute-request (build-schema "query { dog { name owner { name: nameAlias } } }") nil (make-hash-table) nil))
               (data (gethash "data" res))
               (dog-res (gethash "dog" data)))
          (ok (typep res 'hash-table))
          (ok (= (hash-table-count res) 2))
          (ok (= (hash-table-count dog-res) 2))
          (ok (gethash "name" dog-res))
          (ok (gethash "owner" dog-res))))))
  (testing "A query should handle variables and arguments"
    (with-schema (build-schema (asdf:system-relative-pathname 'gql-tests #p"t/test-files/validation-schema.graphql"))
      (let ((variable-values (make-hash-table :test #'equal))
            (query-resolver (make-hash-table :test #'equal))
            (dog-resolver (make-hash-table :test #'equal))
            (*resolvers* (make-hash-table :test #'equal)))
        (setf (gethash "sit" variable-values) "SIT")
        (setf (gethash "Query" *resolvers*) query-resolver)
        (setf (gethash "Dog" *resolvers*) dog-resolver)
        (setf (gethash "dog" query-resolver)
              (lambda () t))
        (setf (gethash "doesKnowCommand" dog-resolver)
              (lambda (args)
                (string= (gethash "dogCommand" args) "SIT")))
        (let* ((res (gql::execute-request
                     (build-schema "query x($sit: String) { dog { doesKnowCommand(dogCommand: $sit) } }")
                     nil
                     variable-values
                     nil))
               (data (gethash "data" res))
               (dog (gethash "dog" data))
               (command (gethash "doesKnowCommand" dog)))
          (ok (= command 1))))))
  (testing "Result coercing"
    (flet ((named-type (name)
             (make-instance 'gql::named-type
                            :name (make-instance 'gql::name :name name))))
      (flet ((test (name value ty &optional return-val)
               (let ((res (gql::coerce-result (named-type name) value)))
                 (and (typep res ty)
                      (equalp res (or return-val value))))))
        (ok (test "Int" 3 'integer))
        (ok (test "Int" -3 'integer))
        (ng (test "String" -3 'integer "Field error for int"))
        (ng (test "Boolean" -3 'integer "Field error for int"))

        (ok (test "Float" -3.9 'double-float))
        (ok (test "Float" 3.9 'double-float))
        (ok (test "Float" 3342.91231236 'double-float))
        (ng (test "Int" 3342.91231236 'double-float))
        (ng (test "String" 3342.91231236 'double-float))
        (ng (test "Boolean" 3342.91231236 'double-float))

        (ok (test "String" "Look at this string!" 'string "Look at this string!"))
        (ok (test "ID" "Look at this string!" 'string))
        (ok (test "Boolean" "Look at this string!" 'string "Field error for string"))
        (ok (test "Int" "Look at this string!" 'string "Field error for string"))
        (ok (test "" "Look at this string!" 'string "Field error for string"))

        (ok (test "Boolean" t '(integer 1) 1))
        (ok (test "Boolean" nil '(integer 0) 0))))))
